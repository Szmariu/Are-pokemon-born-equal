---
title: "Are Pokemon Born Equal? Analisys Using Multidimensional Scaling and Clustering"
author: "Michał Szałański"
date: "10 marca 2019"
output: html_document
---

```{r, echo=FALSE}
knitr::opts_chunk$set(comment=NA)
knitr::opts_chunk$set(fig.align='center')
```

# Introduction
## Goal of the paper

# Data preparation
## Libraries
```{r, Libraries, message = FALSE, warning = FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(corrplot) 
library(labdsv)
library(smacof)
library(psych)
library(pca3d)
library(NbClust)
library(ClusterR)
library(wesanderson)
library(factoextra)
library(clustertend)
library(knitr)
options(scipen=999)

# Define nice colors
cYellow = '#FADA5E'
cBlue = '#378CC7'
```

## Loading the data from a csv. 

The source is a fantastic [Kaggle](https://www.kaggle.com/abcsds/pokemon) dataset containing the statistick for every pokemon released. 

```{r}
pokemon <- read.csv('data/Pokemon.csv')
pokemon <- rename(pokemon, 'Special.Attack' = 'Sp..Atk', 'Special.Defense' = 'Sp..Def')
```

# Data exploration
## First look at the data

```{r, comment=NA, cache = TRUE}
a <- pokemon %>% filter(pokemon$Name == 'Pikachu')
kable(a)
dim(pokemon)
```

Pikachu is present and has the right statistics. Overall, this dataset has 800 observations and 11 variables.

```{r, echo=FALSE, out.width = "250px"}
knitr::include_graphics("assets/pikachu.png")
```

<center>*Pikachu, the most iconic pokemon. Introduced in the 1st generation. Source: bulbapedia.bulbagarden.net*</center>   

```{r, comment=NA, cache = TRUE}
str(pokemon)
```

```{r, cache = TRUE}
a <- summary(pokemon)[,c(1:4,12,13)]
b <- summary(pokemon)[,c(5:11)]
kable(a)
kable(b)
```

The dataset has a nice distribution of variables, 2 categorical, 1 binary and 8 interval. The X variable is a pokemon Id. Note that it is not unique, because later *generations* added new *evolutions* for existing pokemon.  
**Type 1** designates the primary type of the pokemon - it influences it's strengts and weekneses (e.g. fire pokemon are weak against water pokemon) and it's overall design. Some pokemon also have a second type.   
**Generation** is the number of generation this pokemon it's from. First generation originated in 1996, and the 6th one in 2013. This dataset is slightly old, as it lack the 7 generation from 2016.   
Next are the statisticks for each pokemon.The **Total** vairable is a simple sum of all statistics. **HP** stands for Hit Points, the pokemon *health*. **Attack** signifies how much damage can it do, and it's compared to the **defense** of the enemy's pokemon. **Special attack** is simmilar to normal attack, but it's compared to the **Special Defense**. **Speed** indicates which pokemon attacks first in a given round.
Aside from these basic stats, each pokemon has it's *moves*, *abilities* and other variables not included in this dataset. That being said, the basic statline and it's distribution has a great impact on how powerful a given pokemon is.

## Subsetting the dataset 

```{r, cache = TRUE}
# All stats
poke <- pokemon[, c(5:11)]

# All stats, legendary
poke <- pokemon %>% filter(Legendary == 'True')
poke <- poke[, c(6:11)]
poke2 <- pokemon %>% filter(Legendary == 'True')

# Stats without the Total
poke <- pokemon[, c(6:11)]
```

For futher analisys, there are 3 coiches of variables. First is the one including all statistics of a given pokemon - Total, HP, Attack, Defense, Special Attack, Special Defense and Speed. Generations is ignored, since it is a nominal variable.

Second choise are only the Legendary Pokemon - a small (65) subset of all pokemon, containign the rarest and most powerful pokemon.

Third choise it again all pokemon, but withous the Total statistic, since it is produced but all other statistics already included.   
   
   
## Visual analisys   
We can take a look at the overall distirbutions by plotting the scatter plots for all variables. 

```{r, OverallPlot, cache = TRUE, fig.width=8, fig.height=8}
plot(poke, col = cBlue, pch = 19)
```

All variables seem to be nicely distributed, the doesn't seem to be any strong correlations. The HP statitick seems to be the most independent. 
Some outliers can be seen, but they aren't very strong.   

Now, we can take a closer look at the distributions of some of the variables. 

```{r, cache = TRUE}
ggplot(pokemon) + geom_bar(aes(x = Generation), fill = cYellow)
```

The number of pokemon per generation seems to follow a "tick-tok" distribution - each even generation has a significanly lower number of new pokemon. 

```{r, cache = TRUE}
ggplot(pokemon) + geom_bar(aes(x = Legendary), fill = cYellow)
```

There is a large difference beetwen the number of legendary pokemon (65) and normal ones (735)

```{r, cache = TRUE}
ggplot(pokemon) + geom_bar(aes(x = Type.1), fill = cBlue)
```

The number of pokemon in each cattegory in not distibutet evenly. There are a lot more of the *water*, *normal* and *bug* types of pokemons. These might be a design decision, since a lot of the time in-game take place in forrests and simmilar locations. Also notable is the *flying* type - almost no pokemon has it as it's first type. 

```{r, cache = TRUE}
ggplot(pokemon) + geom_bar(aes(x = Type.2), fill = cBlue)
```

Most pokemon don't have a second type - but when they do, it's typically *flying*.  

We can take a look how is the Total variable distributed. It gives a good estimation on how powerful a certain pokemon can be. 

```{r, cache = TRUE}
ggplot(pokemon) + geom_density(aes(x = Total), fill = cYellow, colour = cYellow) 
```

The distribution has two strong peaks - one at around 300, and the other at 500. These is because pokemon has a machanism of *evolution*. Many pokemon (but not all) have at least two forms. One that is weaker (e.g. a bug) and can be encountered earlier in the game, and second (e.g. a butterfly) that is a result of a *evolution* that a pokemon undergoes when it reaches a certain level of expirience. To give a sense of progress, the evolved formes are typically much stronger. 

```{r, cache = TRUE}
ggplot(pokemon) + geom_density(aes(x = Total), fill = cBlue, colour = cBlue) + facet_grid(Legendary ~ .)
```

When comparing the Total beetwen Legendary and non-legendary pokemon, it is claer that most high spots are occupied by the legendary pokemon. They do seem to also follow ths interesting two-peak distribution, even though almost none of the evolve. 

```{r, cache = TRUE}
ggplot(pokemon) + geom_density(aes(x = Total), fill = cYellow, colour = cYellow) + facet_grid(Generation ~ .)
```

We can now see, if there exist any "Power Creep" in pokemon. "Power creep" is a idea, that each new version on generation is stronger than the previous one, typically to help sell new editions. This is a significant problem in many card games. When comparing the Total beetwen generations the "power creep" seems to be nonexitant. It has to be noted that the tow-peak distribution seems to be getting stronger with each generation. 

```{r, cache = TRUE}
ggplot(pokemon) + geom_density(aes(x = Total), fill = cBlue, colour = cBlue) + facet_grid(Generation ~ Legendary)
```

Comparing Total over generations and legendary vs non-legendary pokemon doesn't bring new insights - the distributions seems to be quite consistent.   

We can take a look how are the other variables distributed. 

```{r, cache = TRUE, fig.width=8, fig.height=8}
p1 <- ggplot(pokemon) + geom_density(aes(x = HP), fill = cYellow, colour = cYellow)
p2 <- ggplot(pokemon) + geom_density(aes(x = Attack), fill = cYellow, colour = cYellow)
p3 <- ggplot(pokemon) + geom_density(aes(x = Defense), fill = cYellow, colour = cYellow)
p4 <- ggplot(pokemon) + geom_density(aes(x = Special.Attack), fill = cYellow, colour = cYellow)
p5 <- ggplot(pokemon) + geom_density(aes(x = Special.Defense), fill = cYellow, colour = cYellow)
p6 <- ggplot(pokemon) + geom_density(aes(x = Speed), fill = cYellow, colour = cYellow)
grid.arrange(p1, p2, p3, p4, p5, p6, nrow = 3)
```

All of them follow a roughly normal distribution, with means around 55. Some outliers in each cattegory can be seen. 

## Correlation plot

To see how the variables interact with each other, we can compute and display the correlation matrix. 

```{r, correlationPlot, cache = TRUE}
pokemonCorrelation <- cor(pokemon[, c(6:11)], method="pearson") 
print(pokemonCorrelation, digits=2)
corrplot(pokemonCorrelation, order ="alphabet", method = 'number')
```

There are no strong correlations. Some mild ones can be observed between Defense and Special Defense, and Special Defense and Special Attack. Also note a absolute lack of correlation between Defense and Speed. 


# Multidimensional Scaling
##  Classical multidimentional scaling

After exploring the dataset, we can move to multidimensional scaling. The general idea it that aldough we have 6 (or 7 when counting the Total) variables, there are similarities beetwen them, that would allow us to reduce the number of variables to 2, all without loosing too much information.  

First, we have to compute the distance matrix for our data subset, then feed it into the cmdscale function from the stats package. As a result we'll be able to reduce the number of variables to 2.

```{r, MDS1, cache = TRUE, fig.width=8, fig.height=8}
poke.dist<-dist(poke) 
a <- as.matrix(poke.dist)[1:10, 1:10]
kable(a)
poke.mds.1 <- cmdscale(poke.dist, k=2) 
b <- summary(poke.mds.1)
kable(b)
plot(poke.mds.1) 
```

The results look promising - most of the data is located along the x axis, with some outliers on the top, bottom, and the left side. There are two clear major clusters in the data - maybe they have something to do with the dual-peak distribution discovered earilier? The data also follows a kind of "cone" distribution, having a low variance for x < 0 and higher for x > 0.

## Closer look at the clusters and outliers 

We can try to gain more insights by displaying the names of the pokemon, and comparing the results to a outside source, the pokemon wikipedia.

```{r, cache = TRUE, fig.width=8, fig.height=8}
plot(poke.mds.1, type = 'n')
text(poke.mds.1, labels = pokemon$Name, cex=0.5, adj = 0.5)
```


The plot looks crowded, but we can gain much insight from it. First, we can take a look at the outlier at the bottom, in the center **Shuckle**. According to Bulbapedia *"Shuckle has the most extreme stat distribution of any Pokémon, being either the best or in the bottom three of every base stat"*. This is a great information, because it means the MDS algorithm was able to idenfity the this outlier. 

```{r, echo=FALSE, out.width = "250px"}
knitr::include_graphics("assets/shuckle.png")
```

<center>*Shuckle, looslely based on the real-life endoliths. Introduced in the 2nd generation. Source: bulbapedia.bulbagarden.net*</center>   

Other interesting pokemon are the Pichu, that can be found on the left-hand side in the center, that is one of the weakes pokemons, and Mewtwo Mega, that can be found on the right-hand side, also in the center, that is one of the most powerful pokemon. 


# Idenfyting the infuence of different variables on the MDS
To see the effects of different variables, we can plot their surfaces on the scatter plots. 
We'll be using the pco() function that is a wrapper for the cmdscale() to enable better ploting.

```{r, eval=FALSE}
poke <- pokemon[, c(5:11)]
poke.mds.2<-pco(poke.dist, k=2) 
par(mfrow=c(2,2))
plot(poke.mds.2)
title(main = "PCO")

plot(poke.mds.2)
title(main = "Total")
surf(poke.mds.2, poke$Total)

plot(poke.mds.2)
title(main = "HP")
surf(poke.mds.2, poke$HP)

plot(poke.mds.2)
title(main = "Attack")
surf(poke.mds.2, poke$Attack)

plot(poke.mds.2)
title(main = "Defense")
surf(poke.mds.2, poke$Defense)

plot(poke.mds.2)
title(main = "Special Defense")
surf(poke.mds.2, poke$Special.Defense)

plot(poke.mds.2)
title(main = "Special Attack")
surf(poke.mds.2, poke$Special.Attack)

plot(poke.mds.2)
title(main = "Speed")
surf(poke.mds.2, poke$Speed)

par(mfrow=c(1,1))
```


```{r, MDS2, cache = TRUE, results='hide', fig.width=8, fig.height=8, echo=FALSE}
poke <- pokemon[, c(5:11)]
poke.mds.2<-pco(poke.dist, k=2) 
par(mfrow=c(2,2))
plot(poke.mds.2)
title(main = "PCO")

plot(poke.mds.2)
title(main = "Total")
surf(poke.mds.2, poke$Total)

plot(poke.mds.2)
title(main = "HP")
surf(poke.mds.2, poke$HP)

plot(poke.mds.2)
title(main = "Attack")
surf(poke.mds.2, poke$Attack)

plot(poke.mds.2)
title(main = "Defense")
surf(poke.mds.2, poke$Defense)

plot(poke.mds.2)
title(main = "Special Defense")
surf(poke.mds.2, poke$Special.Defense)

plot(poke.mds.2)
title(main = "Special Attack")
surf(poke.mds.2, poke$Special.Attack)

plot(poke.mds.2)
title(main = "Speed")
surf(poke.mds.2, poke$Speed)

par(mfrow=c(1,1))
```

We can see many interesting interactions. It seems that going along the X axis to the rigth directly increases the Total and Attack statistics. The HP also increases, but only if we stay near the 0 on the Y axis. When analising the Y axis, it seems that going down increases the Defense and Special Defense, while going up and to the left increases the Special Attack and Speed.  

From this, we can see that there is a kind of a trade-off system. The X axis functions as a "power lever", gennerally the further right the more powerful the pokemon.  
All powerful pokemon have higher attack, and Total. As for the other stats, there seems to be 3 paths - the can stay at Y ~ 0, and get more HP, they can get below Y < 0, and get Defense and Special Defense, or they can go Y > 0, and get Special Attack and Speed.  

It seems that for the most powerful pokemon, they can be either Agressive (Y > 0), Defensive (Y < 0), or well-rounded (Y ~ 0). It also looks like the differences are far smaller for the weker pokemon.  

To investigate this further, we can do the same analisys only for the legendary pokemon. 

```{r, eval=FALSE}
poke <- pokemon %>% filter(Legendary == 'True')
poke <- poke[, c(5:11)]
poke.dist<-dist(poke) 
poke.mds.2<-pco(poke.dist, k=2) 
par(mfrow=c(2,2))
plot(poke.mds.2)
title(main = "PCO")

plot(poke.mds.2)
title(main = "Total")
surf(poke.mds.2, poke$Total)

plot(poke.mds.2)
title(main = "HP")
surf(poke.mds.2, poke$HP)

plot(poke.mds.2)
title(main = "Attack")
surf(poke.mds.2, poke$Attack)

plot(poke.mds.2)
title(main = "Defense")
surf(poke.mds.2, poke$Defense)

plot(poke.mds.2)
title(main = "Special Defense")
surf(poke.mds.2, poke$Special.Defense)

plot(poke.mds.2)
title(main = "Special Attack")
surf(poke.mds.2, poke$Special.Attack)

plot(poke.mds.2)
title(main = "Speed")
surf(poke.mds.2, poke$Speed)

par(mfrow=c(1,1))

poke <- pokemon[, c(6:11)]
```


```{r, MDS2Legendary, cache = TRUE, results='hide', fig.width=8, fig.height=8, echo=FALSE}
poke <- pokemon %>% filter(Legendary == 'True')
poke <- poke[, c(5:11)]
poke.dist<-dist(poke) 
poke.mds.2<-pco(poke.dist, k=2) 
par(mfrow=c(2,2))
plot(poke.mds.2)
title(main = "PCO")

plot(poke.mds.2)
title(main = "Total")
surf(poke.mds.2, poke$Total)

plot(poke.mds.2)
title(main = "HP")
surf(poke.mds.2, poke$HP)

plot(poke.mds.2)
title(main = "Attack")
surf(poke.mds.2, poke$Attack)

plot(poke.mds.2)
title(main = "Defense")
surf(poke.mds.2, poke$Defense)

plot(poke.mds.2)
title(main = "Special Defense")
surf(poke.mds.2, poke$Special.Defense)

plot(poke.mds.2)
title(main = "Special Attack")
surf(poke.mds.2, poke$Special.Attack)

plot(poke.mds.2)
title(main = "Speed")
surf(poke.mds.2, poke$Speed)

par(mfrow=c(1,1))

poke <- pokemon[, c(6:11)]
```

The results are simmilar, but there are some differences. As prevously, the X axis serves as a kind of "power level". 
On the Y axis, it looks like that for Y > 0 HP, Defense and Special Defense increase, and for the Y < 0, the Attack and Special Attack increase. Note that while Attack and Special Attack seem to be also correlated with the power level of the creature, this in not true for Defense and Special Defense. Speed seems to be more individual, aldough favouring the Y < 0 side. 

## MDS on variables 

We can test this interactions beetwen variables, by performing the MDS on a transposed subset of our dataset. 

```{r, MDS3, cache = TRUE}
poke.dist.t<-dist(t(pokemon[, c(5:11)]))
poke.mds.3<-cmdscale(poke.dist.t, k=2) 
a <- summary(poke.mds.3)
kable(a)	
plot(poke.mds.3, type = 'n') 
text(poke.mds.3, rownames(poke.mds.3), cex=0.8, adj = 0.5) 
```

The X axis was taken wholey by the Total variable. On the Y axis, we can see a partial confirmation of the conslusions from above - indeed the Speed and Special Attack occupy the Y > 0, and Defense the Y < 0. Only Special Defense seems to be closer to Attack and HP.

## MDS on variables - excluding the Total

To see the differences better, we can perform the analisys again, this time without the Total varaible. 

```{r, MDS3WithoutTotal, cache = TRUE}
poke.dist.t.2<-dist(t(pokemon[, c(6:11)])) 
poke.mds.4<-cmdscale(poke.dist.t.2, k=2) 
a <- summary(poke.mds.4)
kable(a)
plot(poke.mds.4, type = 'n') 
text(poke.mds.4, rownames(poke.mds.4), cex=0.8, adj = 0.5) 
```

Removing the total variable gives a better picture - on this graph the left-top corner represents the Agresive group, the right-top the Defensive, and the bottom-middle the Well-rounded group. 

## Testing the Goodness of Fit

To

```{r, GoodnessOfFit, cache = TRUE}
poke <- pokemon[, c(6:11)]
poke.dist <- dist(t(poke))  
poke.mds.4 <- mds(poke.dist, ndim=2,  type="ordinal") 
poke.mds.4
summary(poke.mds.4)
plot(poke.mds.4)

stress.random.matrix <- randomstress(n=800, ndim=2, nrep = 1) 
poke.mds.4$stress/ mean(stress.random.matrix)
```

# PCA

```{r, PCA1, cache = TRUE}
poke <- pokemon[, c(6:11)]

# PCA
poke.pca.1<-prcomp(poke, center=TRUE, scale.=TRUE) 
poke.pca.1
poke.pca.1$rotation
summary(poke.pca.1)
# Variance plot
plot(poke.pca.1, type = "l")
fviz_pca_var(poke.pca.1, col.var="black")
```

# PCA 2

```{r, PCA2, cache = TRUE}
poke.pca.2<-princomp(poke)
loadings(poke.pca.2)
plot(poke.pca.2)
fviz_pca_var(poke.pca.2, col.var="black")
```

# Rotated and cut - easy interpretation

```{r, PCA3, cache = TRUE}
poke.pca.3 <- principal(poke, nfactors=3, rotate="varimax")
poke.pca.3
summary(poke.pca.3)
# printing only the significant loadings
print(loadings(poke.pca.3), digits=2, cutoff=0.4, sort=TRUE)
```

```{r, cache = TRUE}
fviz_pca_ind(poke.pca.1, col.ind="cos2", geom = "point", gradient.cols = c(cYellow, cBlue))
```

```{r, PCA3d}
# poke.group <- factor(pokemon$Legendary)
#pca3d(poke.pca.1, group = poke.group, legend="topleft")
#pca3d(poke.pca.1, group = poke.group, biplot=TRUE, biplot.vars=3, legend="topleft") 
```

```{r}
#snapshotPCA3d(file="first_plot.png") 
```

############## Clustering k-means

```{r, OptimalClusters, cache = TRUE}
# Prepare data
poke.dist<-dist(poke) 
poke.mds.1 <- cmdscale(poke.dist, k=2) 
poke.mds.1.center <- center_scale(poke.mds.1)
poke.mds.1.center <- poke.mds.1

# Optimal number of clusters
c3<-NbClust(poke.mds.1.center , distance="euclidean", min.nc=2, max.nc=10, method="kmeans", index="silhouette")
c3$All.index

fviz_nbclust(as.data.frame(poke.mds.1), FUNcluster=pam) 
```

# From ClusteR

```{r, CLuster1, cache = TRUE}
poke.km <- KMeans_rcpp(poke.mds.1.center, clusters=4, num_init=30, max_iters = 10000) 
poke.km.pca <- KMeans_rcpp(poke.pca.2$scores[, 1:2], clusters=4, num_init=30, max_iters = 10000) 

x1 <- ggplot(as.data.frame(poke.mds.1.center)) + geom_point(aes(x = V1, y = V2, colour = poke.km$clusters)) + scale_colour_gradientn(colours=wes_palette(n=3, name="BottleRocket2"), guide = FALSE)
x2 <- ggplot(as.data.frame(poke.pca.2$scores[, 1:2])) + geom_point(aes(x = Comp.1, y = Comp.2, colour = poke.km.pca$clusters)) + scale_colour_gradientn(colours=wes_palette(n=3, name="BottleRocket2"), guide = FALSE)
```

```{r}
grid.arrange(x1, x2, nrow=2)
```


# From Factoextra

```{r, cache = TRUE, results='hide', eval = FALSE}
poke.km.2 <- eclust(as.data.frame(poke.mds.1), "kmeans", k = 4)
poke.km.2.pca <- eclust(as.data.frame(poke.pca.2$scores[, 1:2]), "kmeans", k = 4)

fviz_silhouette(poke.km.2)
fviz_silhouette(poke.km.2.pca)
```

```{r, Cluster2, cache = TRUE, results='hide', echo = FALSE}
poke.km.2 <- eclust(as.data.frame(poke.mds.1), "kmeans", k = 4)
poke.km.2.pca <- eclust(as.data.frame(poke.pca.2$scores[, 1:2]), "kmeans", k = 4)

fviz_silhouette(poke.km.2)
fviz_silhouette(poke.km.2.pca)
```

# PAM

```{r, CLuster3cache = TRUE, results='hide', eval = FALSE}
poke.pam <- eclust(as.data.frame(poke.mds.1), "pam", k = 4)
poke.pam.2 <- eclust(as.data.frame(poke.pca.2$scores[, 1:2]), "pam", k = 4)
fviz_silhouette(poke.pam)
fviz_silhouette(poke.pam.2)
```

```{r, CLuster3cache = TRUE, results='hide', echo = FALSE}
poke.pam <- eclust(as.data.frame(poke.mds.1), "pam", k = 4)
poke.pam.2 <- eclust(as.data.frame(poke.pca.2$scores[, 1:2]), "pam", k = 4)
fviz_silhouette(poke.pam)
fviz_silhouette(poke.pam.2)
```






